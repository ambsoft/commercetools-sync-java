package com.commercetools.sync.categories.utils;

import io.sphere.sdk.categories.Category;
import io.sphere.sdk.categories.commands.updateactions.AddAsset;
import io.sphere.sdk.categories.commands.updateactions.ChangeAssetOrder;
import io.sphere.sdk.categories.commands.updateactions.RemoveAsset;
import io.sphere.sdk.commands.UpdateAction;

import javax.annotation.Nonnull;
import java.util.ArrayList;
import java.util.List;

final class UpdateActionsSortUtils {
    /**
     * Given a list of update actions, this method returns a copy of the supplied list but sorted with the following
     * precedence:
     * <ol>
     * <li>{@link io.sphere.sdk.categories.commands.updateactions.RemoveAsset}</li>
     * <li>{@link io.sphere.sdk.categories.commands.updateactions.ChangeAssetName} OR
     * {@link io.sphere.sdk.categories.commands.updateactions.SetAssetDescription} OR
     * {@link io.sphere.sdk.categories.commands.updateactions.SetAssetTags} OR
     * {@link io.sphere.sdk.categories.commands.updateactions.SetAssetSources} OR
     * {@link io.sphere.sdk.categories.commands.updateactions.SetAssetCustomField} OR
     * {@link io.sphere.sdk.categories.commands.updateactions.SetAssetCustomType}</li>
     * <li>{@link io.sphere.sdk.categories.commands.updateactions.ChangeAssetOrder}</li>
     * <li>{@link io.sphere.sdk.categories.commands.updateactions.AddAsset}</li>
     * </ol>
     *
     * <p>This is to ensure that there are no conflicts when adding a new asset that might have a duplicate value for
     * a unique field, which could already be changed or removed. It is important to have a changeAssetOrder action
     * before an addAsset action, since changeAssetOrder requires asset ids for sorting them, and new assets don't have
     * ids yet since they are generated by CTP after an asset is created. Therefore, first set the correct order, then
     * we add the asset at the correct index.
     *
     * @param updateActions list of update actions to sort.
     * @return a new sorted list of update actions.
     */
    @Nonnull
    static List<UpdateAction<Category>> sortAssetActions(
        @Nonnull final List<UpdateAction<Category>> updateActions) {

        final List<UpdateAction<Category>> actionsCopy = new ArrayList<>(updateActions);

        actionsCopy.sort((action1, action2) -> {
            if (action1 instanceof RemoveAsset && !(action2 instanceof RemoveAsset)) {
                return -1;
            }

            if (!(action1 instanceof RemoveAsset) && action2 instanceof RemoveAsset) {
                return 1;
            }

            if (!(action1 instanceof AddAsset) && action2 instanceof AddAsset) {
                return -1;
            }

            if (action1 instanceof AddAsset && !(action2 instanceof AddAsset)) {
                return 1;
            }

            if (!(action1 instanceof ChangeAssetOrder) && action2 instanceof ChangeAssetOrder) {
                return -1;
            }

            if (action1 instanceof ChangeAssetOrder && !(action2 instanceof ChangeAssetOrder)) {
                return 1;
            }

            return 0;
        });
        return actionsCopy;
    }

    private UpdateActionsSortUtils() {
    }
}
